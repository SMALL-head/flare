// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package fileAudit

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type fileAuditEventT struct {
	Pid        int32
	Fmode      int32
	Comm       [16]int8
	Filename   [160]int8
	MntNsInode uint32
	FileInode  uint32
}

type fileAuditFileInfoMap struct{ Files [10]uint32 }

// loadFileAudit returns the embedded CollectionSpec for fileAudit.
func loadFileAudit() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_FileAuditBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load fileAudit: %w", err)
	}

	return spec, err
}

// loadFileAuditObjects loads fileAudit and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*fileAuditObjects
//	*fileAuditPrograms
//	*fileAuditMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadFileAuditObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadFileAudit()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// fileAuditSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type fileAuditSpecs struct {
	fileAuditProgramSpecs
	fileAuditMapSpecs
	fileAuditVariableSpecs
}

// fileAuditProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type fileAuditProgramSpecs struct {
	LsmFileOpenContainer *ebpf.ProgramSpec `ebpf:"lsm_file_open_container"`
}

// fileAuditMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type fileAuditMapSpecs struct {
	AuditFilesMap   *ebpf.MapSpec `ebpf:"audit_files_map"`
	Dummy           *ebpf.MapSpec `ebpf:"dummy"`
	FileAuditEvents *ebpf.MapSpec `ebpf:"file_audit_events"`
}

// fileAuditVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type fileAuditVariableSpecs struct {
}

// fileAuditObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadFileAuditObjects or ebpf.CollectionSpec.LoadAndAssign.
type fileAuditObjects struct {
	fileAuditPrograms
	fileAuditMaps
	fileAuditVariables
}

func (o *fileAuditObjects) Close() error {
	return _FileAuditClose(
		&o.fileAuditPrograms,
		&o.fileAuditMaps,
	)
}

// fileAuditMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadFileAuditObjects or ebpf.CollectionSpec.LoadAndAssign.
type fileAuditMaps struct {
	AuditFilesMap   *ebpf.Map `ebpf:"audit_files_map"`
	Dummy           *ebpf.Map `ebpf:"dummy"`
	FileAuditEvents *ebpf.Map `ebpf:"file_audit_events"`
}

func (m *fileAuditMaps) Close() error {
	return _FileAuditClose(
		m.AuditFilesMap,
		m.Dummy,
		m.FileAuditEvents,
	)
}

// fileAuditVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadFileAuditObjects or ebpf.CollectionSpec.LoadAndAssign.
type fileAuditVariables struct {
}

// fileAuditPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadFileAuditObjects or ebpf.CollectionSpec.LoadAndAssign.
type fileAuditPrograms struct {
	LsmFileOpenContainer *ebpf.Program `ebpf:"lsm_file_open_container"`
}

func (p *fileAuditPrograms) Close() error {
	return _FileAuditClose(
		p.LsmFileOpenContainer,
	)
}

func _FileAuditClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed fileaudit_x86_bpfel.o
var _FileAuditBytes []byte
